#!/usr/bin/env python

# Parameter and Types:
#  https://learn.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/parameters-parameter

# Parameter Keys:
# Required: name, type
# Optional: displayName, default, values

# Data Types:
# string, number, boolean, object

# Note: There is no native way to enforce an object's structure.

import yaml
import sys
import os
import tempfile


class ADOPipelineDocException(Exception):
  pass


class ADOPipelineDoc:
  #---------------------------------------------------------------------------
  def __init__(self, yamlFile=None, mdFile=None):
    """
    Initializes the ADOPipelineDoc with a given YAML input file and an
    optional output file.

    Args:
      yamlFile (str): The path to the YAML file containing pipeline parameters.
      mdFile (str, optional): The path to the output file where the processed data will be saved.

    Raises:
      ADOPipelineDocException: If no input file is provided.
    """
    self.data = None
    self.mdEnd = 'ADOPipelineDoc End'
    self.mdFile = mdFile
    self.mdStart = 'ADOPipelineDoc Start'
    self.yamlFile = yamlFile

    if self.yamlFile is None:
      raise ADOPipelineDocException(
        "Input file must be provided to ADOPipelineDoc.")

    self.parseYAML()
    self.processData()

    if self.mdFile is None:
      print("\n".join(self.table_rows))
    else:
      self.writeFile()

  #---------------------------------------------------------------------------
  def mdStartStr(self):
    return f"<!-- {self.mdStart} -->"

  def mdEndStr(self):
    return f"<!-- {self.mdEnd} -->"

  def printTable(self):
    # Make this a correct one liner for perl, AI!
    print(f"{self.mdStartStr}") if self.mdFile is None
    print("\n".join(self.table_rows))
  #---------------------------------------------------------------------------
  def readFile(self, file_path):
    """
    Reads the content of a file.

    Args:
      file_path (str): The path to the file to be read.

    Returns:
      str: The content of the file.

    Raises:
      ADOPipelineDocException: If the file cannot be accessed.
    """
    try:
      with open(file_path, 'r') as file:
        return file.read()

    except FileNotFoundError:
      raise ADOPipelineDocException(f"The file {file_path} was not found.")

    except PermissionError:
      raise ADOPipelineDocException(
        f"Permission denied for file {file_path}.")

  #---------------------------------------------------------------------------
  def prettyObject(self, obj, key=None):
    """
    Converts a given object to a pretty-printed string format.

    Args:
      obj (any): The object to be converted to a string.
      key (str, optional): The key associated with the object.

    Returns:
      str: A pretty-printed string representation of the object.

    Raises:
      ADOPipelineDocException:
        - If a key is passed and the object is not a dictionary.
        - If the key is not found in the object.
    """
    if key is not None:
      pretty = yaml.dump(obj[key], default_flow_style=False)

    else:
      pretty = yaml.dump(obj, default_flow_style=False)

    return pretty.strip().replace('\n', '<br/>')

  #---------------------------------------------------------------------------
  def parseYAML(self):
    """
    Loads the YAML file specified by the filename attribute and stores its
    parsed contents in the data attribute.

    Raises:
      ADOPipelineDocException:
        - If the YAML file is empty or contains null data.
        - If the YAML file has no parameters.
        - If there is an error in parsing the YAML content.
    """
    try:
      content = self.readFile(self.yamlFile)
      data = yaml.safe_load(content)

      if data is None:
        raise ADOPipelineDocException(
          "YAML file is empty or contains null data.")

      params = data.get('parameters', [])

      if not params:
        raise ADOPipelineDocException("YAML file has no parameters.")

      self.data = data
      self.parameters = params

    except yaml.YAMLError as e:
      raise ADOPipelineDocException(f"Error parsing YAML file: {e}")

  #---------------------------------------------------------------------------
  def processData(self):
    """
    Processes the YAML parameters and converts them into a markdown table format.

    This method checks each parameter for required fields and optional fields
    like displayName, values, and default. It constructs a markdown table with
    headers and rows representing each parameter's details. The table is stored
    in the table_rows attribute.

    Raises:
      ADOPipelineDocException: If a parameter is missing 'name' or 'type'.
    """
    heading_order = [
      'required', 'name', 'type', 'displayName', 'values', 'default'
    ]

    heading_separator = {
      "required": ":-:",
      "name": ":--",
      "type": ":--",
      "displayName": ":--",
      "values": ":--",
      "default": ":--"
    }

    object_template = {
      "required": "Yes",
      "name": '',
      "type": '',
      "displayName": '',
      "values": '',
      "default": ''
    }

    use_col = {"displayName": False, "values": False, "default": False}

    rows = []

    for param in self.parameters:
      if not param.get('name') or not param.get('type'):
        raise ADOPipelineDocException(
          f"Parameter missing 'name' or 'type': {param}")

      if param.get('displayName', ''):
        use_col["displayName"] = True

      if param.get('values', ''):
        use_col["values"] = True

      row_object = object_template.copy()
      row_object.update(param)

      if param.get('default', ''):
        use_col["default"] = True
        row_object["required"] = ''

      if param.get('type') == 'object' and param.get('default'):
        row_object['default'] = self.prettyObject(param, key='default')

      if param.get('values'):
        row_object['values'] = self.prettyObject(param, key='values')

      rows.append(row_object)

    for key, value in use_col.items():
      if not value:
        heading_order.remove(key)
        for row in rows:
          row.pop(key, None)

    table_rows = []

    # Build the markdown header row
    header_row = "| " + " | ".join(heading_order) + " |"
    separator_row = "| " + " | ".join(heading_separator[key]
                                      for key in heading_order) + " |"

    # Add header and separator to table_rows
    table_rows.append(header_row)
    table_rows.append(separator_row)

    # Add parameter rows to table_rows
    for row in rows:
      row_data = [str(row.get(key, '')) for key in heading_order]
      row_text = "| " + " | ".join(row_data) + " |"
      table_rows.append(row_text)

    self.table_rows = table_rows

  #---------------------------------------------------------------------------
  def writeFile(self):
    """
    Manages the markdown file based on the presence of start and end comments.
    If the file doesn't exist, it creates a new file and writes the data.
    If the file exists but has no comments, it appends the data to the end.
    If the file exists and both comments are missing, raises an error.
    Replaces existing text between comments with the data.
    
    Raises:
      ADOPipelineDocException: If the file exists and both comments are missing.
    """
    if self.mdFile is None:
      raise ADOPipelineDocException("Output file must be provided to ADOPipelineDoc.")

    try:
      content = self.readFile(self.mdFile)

      start_index = content.find(self.mdStartStr())
      end_index = content.find(self.mdEndStr())

      if start_index == -1 and end_index == -1:
        raise ADOPipelineDocException(f"No start and end comments found in {mdFile}.")

      # Create a temporary file
      with tempfile.NamedTemporaryFile('w', delete=False) as temp_file:
        temp_file_name = temp_file.name

        if start_index == -1 or end_index == -1:
          temp_file.write(content + "\n" + "\n".join(self.table_rows))
        else:
          new_content = (content[:start_index] + "\n".join(self.table_rows) +
                         content[end_index + len(f"<!-- {self.mdEnd} -->"):])
          temp_file.write(new_content)

      # Replace the original file with the temporary file
      os.replace(temp_file_name, self.mdFile)

    except FileNotFoundError:
      with open(self.mdFile, 'w') as file:
        file.write("\n".join(self.table_rows))


if __name__ == "__main__":
  ADOPipelineDoc('azure-pipelines.yml')
